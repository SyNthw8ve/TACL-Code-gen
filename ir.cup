import java_cup.runtime.*;

import java.io.InputStreamReader;
import classes.other.*;
import classes.nodes.*;

import java.util.LinkedList;

parser code {:

  SymbolTable symbol_table = new SymbolTable();

  public static void main(String args[]) throws Exception {

    IR ir = new IR(new Yylex(new InputStreamReader(System.in)));

    Symbol result = null;

    try {

      result = ir.parse();
    }
    catch(Exception e) {

      System.err.print("** Caught: ");

      e.printStackTrace();
    }

    if (result != null && result.sym == sym.EOF)
      System.exit(0);
    else
      System.exit(1);
  }

  public void report_error(String message, Object error_info) {
    Symbol info = (Symbol) error_info;

    System.err.print(message + ": line " + (info.right + 1) + ": " );
    System.err.println("unexpected token `" + info.value + "'");
  }

  public void report_fatal_error(String message, Object _ignore) {
    System.err.println(message);
  }
:};

terminal String ID, LABEL, I_TEMP;
terminal Integer I_LIT, B_LIT;
terminal LS_PAR, RS_PAR, L_PAR, R_PAR, COL, COMMA;
terminal ID_K, VAR, FUN, FUNCTION, INT, BOOL, VOID;
terminal IR_STORE;

terminal I_ADD, I_SUB, I_MUL, I_DIV, I_INV, I_COPY, MOD;
terminal I_EQ, I_NE, I_LT, I_LE;

terminal I_VAL, I_GLOAD, I_LLOAD, I_ALOAD, I_GSTORE, I_LSTORE, I_ASTORE;
terminal I_CALL, I_RET;

terminal P_CALL, P_RET;

terminal NOT;

terminal JUMP, CJUMP;
terminal I_PRINT, B_PRINT, I_READ, B_READ;

non terminal LinkedList<GlobalDec> global_decs;
non terminal GlobalDec global_dec;
non terminal Integer intial_value;
non terminal LinkedList<Pair> formals, locals;
non terminal Pair pair;
non terminal LinkedList<Label> labels;
non terminal LinkedList<Temp> actual_args, more_actual_args;

non terminal IRDec ir_dec;
non terminal LinkedList<IRDec> ir_decs, root;

non terminal Temp int_temp, actual_arg;

non terminal LinkedList<Statement> ir_statements, function_body;
non terminal Type type;
non terminal Node ir_expr, jump_expr, call_expr, io_expr, ret_expr, int_expr;
non terminal Head function_head;

root ::= global_decs:g ir_decs:i {: RESULT = i; TreeWalk t = new TreeWalk(parser.symbol_table, i, g); t.walk();:};

global_decs ::=    	global_dec:g global_decs:gs {: gs.addFirst(g); RESULT = gs; :}
                	|   {: RESULT = new LinkedList<GlobalDec>(); :}
					;

global_dec ::=  L_PAR ID_K ID:s VAR type:t R_PAR {: Info i = new Info(Info.Types.VAR, null, null, null, t); 
																		parser.symbol_table.add(s, i); RESULT = new GlobalDec(s);:}
			|	L_PAR ID_K ID:s VAR type:t intial_value:v R_PAR 
			{: Info i = new Info(Info.Types.VAR_INIT, null, null, v, t);
				parser.symbol_table.add(s, i); RESULT = new GlobalDec(s);:}
			|	L_PAR ID_K ID:s FUN type:t LS_PAR formals:f RS_PAR LS_PAR locals:l RS_PAR R_PAR {: Info i = new Info(Info.Types.FUN, f, l, null, t); 
																								parser.symbol_table.add(s, i); RESULT = new GlobalDec(s);:}
			;

ir_decs ::= ir_dec:d ir_decs:ds {: ds.addFirst(d); RESULT = ds; :}
			|	{: RESULT = new LinkedList<IRDec>(); :}
			;

ir_dec ::= 	function_head:h function_body:b {: RESULT = new IRDec(h, b); :}
			;

function_head ::= FUNCTION ID:s {: RESULT = new Head(s); :};

function_body ::= ir_statements:s {: RESULT = s; :}
				;

ir_statements ::= labels:l ir_expr:e ir_statements:s {: Statement st = new Statement(l, e); s.addFirst(st); RESULT = s; :}
				| {: RESULT =  new LinkedList<Statement>(); :}
				;

labels ::= 	{: RESULT = new LinkedList<Label>(); :}
			| LABEL:s COL labels:l {: Label la = new Label(s); l.addFirst(la); RESULT = l; :}
			;

ret_expr ::=	I_RET int_temp:t  {: RESULT = new Return(t); :}
			|	P_RET {: RESULT = new Return(null); :}
			;

int_temp ::=	I_TEMP:s {: RESULT = new Temp(s); :}
			;


ir_expr ::= 	int_expr:e {:RESULT = e;:}
			|	jump_expr:e {:RESULT = e;:}
			|	call_expr:e {:RESULT = e;:}
			|	io_expr:e {:RESULT = e;:}
			|	ret_expr:e {:RESULT = e;:}
			;

int_expr ::=	int_temp:t IR_STORE I_VAL I_LIT:i {: RESULT = new Value(t, i); :}
			|	int_temp:t IR_STORE I_GLOAD ID:s {: RESULT = new Store(Store.Type.GLOBAL, s, t); :}
			|	int_temp:t IR_STORE I_LLOAD ID:s {: RESULT = new Store(Store.Type.LOCAL, s, t); :}
			|	int_temp:t IR_STORE I_ALOAD ID:s {: RESULT = new Store(Store.Type.ARG, s, t); :}
			|	ID:s IR_STORE I_GSTORE int_temp:t {: RESULT = new Load(Load.Type.GLOBAL, s, t); :}
			|	ID:s IR_STORE I_LSTORE int_temp:t {: RESULT = new Load(Load.Type.LOCAL, s, t); :}
			|	ID:s IR_STORE I_ASTORE int_temp:t {: RESULT = new Load(Load.Type.ARG, s, t); :}
			|	int_temp:t IR_STORE I_ADD int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_ADD, t, t1, t2); :}
			|	int_temp:t IR_STORE I_SUB int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_SUB, t, t1, t2); :}
			|	int_temp:t IR_STORE I_MUL int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_MUL, t, t1, t2); :}
			|	int_temp:t IR_STORE I_DIV int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_DIV, t, t1, t2); :}
			|	int_temp:t IR_STORE MOD int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.MOD, t, t1, t2); :}
			|	int_temp:t IR_STORE I_INV int_temp:t1 {: RESULT = new Unop(Unop.Type.I_INV, t, t1); :}
			|	int_temp:t IR_STORE NOT int_temp:t1 {: RESULT = new Unop(Unop.Type.NOT, t, t1); :}
			|	int_temp:t IR_STORE I_EQ int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_EQ, t, t1, t2); :}
			|	int_temp:t IR_STORE I_LT int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_LT, t, t1, t2); :}
			|	int_temp:t IR_STORE I_NE int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_NE, t, t1, t2); :}
			|	int_temp:t IR_STORE I_LE int_temp:t1 COMMA int_temp:t2 {: RESULT = new Binop(Binop.Type.I_LE, t, t1, t2); :}
			|	int_temp:t IR_STORE I_COPY int_temp:t1 {: RESULT = new Unop(Unop.Type.I_COPY, t, t1); :}
			;

jump_expr ::=	CJUMP int_temp:t COMMA LABEL:l1 COMMA LABEL:l2 {: Label lt = new Label(l1); Label lf = new Label(l2); RESULT = new Cjump(t, lt, lf); :}
			|	JUMP LABEL:l {: Label lt = new Label(l); RESULT = new Jump(lt); :}
			;

call_expr ::= 	int_temp:tt IR_STORE I_CALL ID:n COMMA LS_PAR actual_args:al RS_PAR {: RESULT = new Fcall(n, al, tt); :}
			|	P_CALL ID:n LS_PAR actual_args:al RS_PAR {: RESULT = new Fcall(n, al, null); :}
			;

actual_arg ::= 	int_temp:t {: RESULT = t; :} ;

more_actual_args ::= COMMA actual_arg:a more_actual_args:al {: al.addFirst(a); RESULT = al; :}
				| {: RESULT = new LinkedList<Temp>(); :}
				;

actual_args ::= actual_arg:a more_actual_args:al {: al.addFirst(a); RESULT = al; :}
			| {: RESULT = new LinkedList<Temp>(); :}
			;

io_expr ::= I_PRINT int_temp:t {: RESULT = new Print(Print.Type.INT, t); :}
		|	B_PRINT int_temp:t {: RESULT = new Print(Print.Type.BOOL, t); :}
		|	int_temp:t IR_STORE I_READ {: RESULT = new Read(Read.Type.INT, t); :}
		|	int_temp:t IR_STORE B_READ {: RESULT = new Read(Read.Type.BOOL, t); :}
		;

type ::= 	INT {: RESULT = new Type(Type.Types.INT); :}
		|	BOOL {: RESULT = new Type(Type.Types.BOOL); :}
		|	VOID {: RESULT = new Type(Type.Types.VOID); :}
		;

intial_value ::= 	I_LIT:i {:RESULT = i;:}
				|	B_LIT:b {:RESULT = b;:}
				;

formals ::=		pair:p formals:f {: f.addFirst(p); RESULT = f; :}
			|	{: RESULT = new LinkedList<Pair>(); :}
			;

locals ::=		pair:p locals:l {: l.addFirst(p); RESULT = l; :}
			|	{: RESULT = new LinkedList<Pair>(); :}
			;

pair ::= 		L_PAR INT ID:s R_PAR {: RESULT = new Pair(s, Pair.Type.INT); :}
			|	L_PAR BOOL ID:s R_PAR {: RESULT = new Pair(s, Pair.Type.BOOL); :}
			;